#!/usr/bin/env python3
"""
Create GitHub issues for failed downloads and patches
"""

import os
import json
import sys
import argparse
from pathlib import Path
from datetime import datetime
from github import Github

OUTPUT_DIR = Path("output")
DOWNLOADS_DIR = Path("downloads")

def read_log_file(log_path):
    """Read log file content"""
    try:
        with open(log_path, 'r') as f:
            return f.read()
    except:
        return "Log file not available"

def create_issue_for_patch_failure(repo, item, date_str):
    """Create a GitHub issue for a failed patch"""
    
    app = item['app']
    app_name = app['name']
    package_name = app['package_name']
    error = item.get('error', 'Unknown error')
    log_file = item.get('log_file')
    
    # Create issue title
    issue_title = f"[AUTO] Failed to patch: {app_name}"
    
    # Read log file if available
    log_content = ""
    if log_file and Path(log_file).exists():
        full_log = read_log_file(log_file)
        # Truncate log if too long (GitHub has limits)
        if len(full_log) > 60000:
            log_content = full_log[:30000] + "\n\n... [LOG TRUNCATED] ...\n\n" + full_log[-30000:]
        else:
            log_content = full_log
    
    # Create issue body
    issue_body = f"""## üî¥ Automatic Patch Failure Report

**Date:** {date_str}
**App Name:** {app_name}
**Package Name:** `{package_name}`

### Error Summary
```
{error[:1000]}
```

### App Configuration
```json
{json.dumps(app, indent=2)}
```

### Full Error Log
<details>
<summary>Click to expand full log</summary>

```
{log_content}
```

</details>

### Possible Causes
- APK version may be incompatible with current patches
- Download URL may have changed or be invalid
- ReVanced patches may need updating
- Specific patches for this app may be broken

### Next Steps
1. Check if the app download URL is still valid
2. Verify the app version is supported by ReVanced patches
3. Check [ReVanced GitHub](https://github.com/ReVanced) for any known issues
4. Try updating ReVanced tools to the latest version

---
*This issue was automatically generated by GitHub Actions.*
*Build: {os.environ.get('GITHUB_RUN_ID', 'unknown')}*
"""
    
    return create_issue(repo, issue_title, issue_body, ['patch-failed', 'automated'], app_name)

def create_issue_for_download_failure(repo, item, date_str):
    """Create a GitHub issue for a failed download"""
    
    app = item['app']
    app_name = app['name']
    package_name = app['package_name']
    error = item.get('error', 'Unknown error')
    
    # Create issue title
    issue_title = f"[AUTO] Failed to download: {app_name}"
    
    # Read missing architectures log if available
    missing_arch_content = ""
    missing_arch_file = DOWNLOADS_DIR / "missing_architectures.json"
    if missing_arch_file.exists():
        try:
            with open(missing_arch_file, 'r') as f:
                missing_data = json.load(f)
            # Filter for this app
            app_missing = [entry for entry in missing_data if entry['package_name'] == package_name]
            if app_missing:
                missing_arch_content = json.dumps(app_missing[-1], indent=2)
        except:
            pass
    
    # Create issue body
    issue_body = f"""## üî¥ Automatic Download Failure Report

**Date:** {date_str}
**App Name:** {app_name}
**Package Name:** `{package_name}`

### Error Summary
```
{error[:1000]}
```

### App Configuration
```json
{json.dumps(app, indent=2)}
```

### Missing Architecture Details
<details>
<summary>Click to expand architecture analysis</summary>

```json
{missing_arch_content}
```

</details>

### Possible Causes
- APKMirror page structure changed
- Required architecture variants not available
- Download URL may have changed or be invalid
- APKMirror may be blocking automated requests
- Network/timeout issues

### Next Steps
1. Manually check the app's APKMirror page: `{app.get('download_url', 'N/A')}`
2. Verify if the requested architectures are available
3. Check if APKMirror has changed their page structure
4. Review the ReVanced supported versions for this app

---
*This issue was automatically generated by GitHub Actions.*
*Build: {os.environ.get('GITHUB_RUN_ID', 'unknown')}*
"""
    
    return create_issue(repo, issue_title, issue_body, ['download-failed', 'automated'], app_name)

def create_issue(repo, title, body, labels, app_name):
    """Create a GitHub issue with deduplication"""
    
    # Check if similar issue already exists
    existing_issues = repo.get_issues(
        state='open',
        labels=labels,
        creator='github-actions[bot]'
    )
    
    for issue in existing_issues:
        if app_name.lower() in issue.title.lower():
            print(f"  ‚ÑπÔ∏è  Similar issue already exists: {issue.title} (#{issue.number})")
            # Update the existing issue with new information
            comment_body = f"""## üîÑ Updated Failure Report - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

{body.split('### Error Summary')[1] if '### Error Summary' in body else 'New failure detected.'}

---
*Updated by automated workflow - Build: {os.environ.get('GITHUB_RUN_ID', 'unknown')}*
"""
            issue.create_comment(comment_body)
            return issue
    
    # Create new issue if none exists
    issue = repo.create_issue(
        title=title,
        body=body,
        labels=labels
    )
    print(f"  ‚úì Created issue: {title} (#{issue.number})")
    return issue

def handle_download_failures():
    """Handle download failures by creating GitHub issues"""
    # Load download results
    results_file = DOWNLOADS_DIR / "download_results.json"
    if not results_file.exists():
        print("No download results found - skipping download failure handling")
        return
    
    with open(results_file, 'r') as f:
        results = json.load(f)
    
    if not results.get('failed'):
        print("No download failures found")
        return
    
    # Get GitHub repository
    github_token = os.environ.get('GITHUB_TOKEN')
    if not github_token:
        print("GITHUB_TOKEN not found - cannot create issues")
        return
    
    g = Github(github_token)
    repo = g.get_repo(os.environ.get('GITHUB_REPOSITORY', ''))
    
    date_str = datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')
    
    print(f"Creating issues for {len(results['failed'])} download failures...")
    
    for item in results['failed']:
        try:
            create_issue_for_download_failure(repo, item, date_str)
        except Exception as e:
            print(f"  ‚úó Failed to create issue for {item['app']['name']}: {e}")

def handle_patch_failures():
    """Handle patch failures by creating GitHub issues"""
    # Load patch results
    results_file = OUTPUT_DIR / "patch_results.json"
    if not results_file.exists():
        print("No patch results found - skipping patch failure handling")
        return
    
    with open(results_file, 'r') as f:
        results = json.load(f)
    
    if not results.get('failed'):
        print("No patch failures found")
        return
    
    # Get GitHub repository
    github_token = os.environ.get('GITHUB_TOKEN')
    if not github_token:
        print("GITHUB_TOKEN not found - cannot create issues")
        return
    
    g = Github(github_token)
    repo = g.get_repo(os.environ.get('GITHUB_REPOSITORY', ''))
    
    date_str = datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')
    
    print(f"Creating issues for {len(results['failed'])} patch failures...")
    
    for item in results['failed']:
        try:
            create_issue_for_patch_failure(repo, item, date_str)
        except Exception as e:
            print(f"  ‚úó Failed to create issue for {item['app']['name']}: {e}")

def main():
    """Main function to handle different types of failures"""
    parser = argparse.ArgumentParser(description='Create GitHub issues for failures')
    parser.add_argument('--type', choices=['download', 'patch'], required=True,
                        help='Type of failures to handle')
    
    args = parser.parse_args()
    
    if args.type == 'download':
        handle_download_failures()
    elif args.type == 'patch':
        handle_patch_failures()

if __name__ == "__main__":
    main()