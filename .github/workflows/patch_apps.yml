name: Patch APKs with ReVanced

on:
  schedule:
    - cron: '0 0 * * *' # Daily at midnight UTC
  workflow_dispatch: # Allow manual trigger
  push:
    branches: [initial-setup, main]
    # Uncomment below to only trigger on config changes:
    # paths:
    #   - 'config/apps.json'

jobs:
  patch-and-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'zulu'
          java-version: '17'

      - name: Install Python dependencies
        run: |
          pip install -r requirements.txt

      - name: Download ReVanced tools
        run: |
          python scripts/setup_revanced.py
          # Exit codes: 0=success, 1=critical error (fail pipeline)

      - name: Generate Patch Analysis
        run: |
          python scripts/patch_analyzer.py
          # Analyzes ReVanced patches to determine latest supported app versions

      - name: Check if Release is Needed
        id: release_check
        run: |
          python scripts/release_checker.py
          # Checks if there are new versions that need to be released

      - name: Log No Release Needed
        if: steps.release_check.outputs.needs_release != 'true'
        run: |
          echo "âœ… No new versions detected - skipping release pipeline"
          echo "All currently supported app versions have already been released."
          python scripts/pipeline_orchestrator.py log --skip-release

      - name: Download APKs
        if: steps.release_check.outputs.needs_release == 'true'
        run: |
          python scripts/downloader.py
          # Exit codes: 0=success, 1=critical error (fail pipeline), 2=all failed (continue to issues)

      - name: Analyze Download Results
        id: download_analysis
        if: steps.release_check.outputs.needs_release == 'true'
        run: |
          if [ -f "downloads/download_results.json" ]; then
            echo "download_results_exist=true" >> $GITHUB_OUTPUT
            successful=$(python -c "import json; data=json.load(open('downloads/download_results.json')); print(len(data['successful']))")
            failed=$(python -c "import json; data=json.load(open('downloads/download_results.json')); print(len(data['failed']))")
            echo "download_successful=$successful" >> $GITHUB_OUTPUT
            echo "download_failed=$failed" >> $GITHUB_OUTPUT
          else
            echo "download_results_exist=false" >> $GITHUB_OUTPUT
            echo "download_successful=0" >> $GITHUB_OUTPUT
            echo "download_failed=0" >> $GITHUB_OUTPUT
          fi

      - name: Patch APKs
        id: patch
        if: steps.release_check.outputs.needs_release == 'true' && steps.download_analysis.outputs.download_successful > 0
        run: |
          python scripts/patcher.py
          # Exit codes: 0=success, 1=critical error (fail pipeline), 2=all failed (continue to issues)
        continue-on-error: false

      - name: Analyze Patch Results
        id: patch_analysis
        if: always() && steps.release_check.outputs.needs_release == 'true' && steps.download_analysis.outputs.download_successful > 0
        run: |
          if [ -f "output/patch_results.json" ]; then
            echo "patch_results_exist=true" >> $GITHUB_OUTPUT
            successful=$(python -c "import json; data=json.load(open('output/patch_results.json')); print(len(data['successful']))")
            failed=$(python -c "import json; data=json.load(open('output/patch_results.json')); print(len(data['failed']))")
            echo "success_count=$successful" >> $GITHUB_OUTPUT
            echo "failure_count=$failed" >> $GITHUB_OUTPUT
          else
            echo "patch_results_exist=false" >> $GITHUB_OUTPUT
            echo "success_count=0" >> $GITHUB_OUTPUT
            echo "failure_count=0" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub Release
        if: steps.release_check.outputs.needs_release == 'true' && steps.patch_analysis.outputs.success_count > 0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python scripts/release_manager.py

      - name: Create Issues for Download Failures
        if: always() && steps.release_check.outputs.needs_release == 'true' && steps.download_analysis.outputs.download_failed > 0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Creating issues for download failures..."
          python scripts/issue_manager.py --type download

      - name: Create Issues for Patch Failures
        if: always() && steps.release_check.outputs.needs_release == 'true' && steps.patch_analysis.outputs.failure_count > 0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Creating issues for patch failures..."
          python scripts/issue_manager.py --type patch

      - name: Log Pipeline Completion
        if: always()
        run: |
          python scripts/pipeline_orchestrator.py log

      - name: Commit Logs
        if: always()
        run: |
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Only proceed if there are logs to commit
          if [ -d "logs" ] && [ "$(ls -A logs)" ]; then
            # Create or switch to release-logs branch
            git fetch origin release-logs:release-logs 2>/dev/null || git checkout --orphan release-logs
            if git show-ref --verify --quiet refs/heads/release-logs; then
              git checkout release-logs
            fi
            
            # Remove any non-log files that might be in this branch
            find . -maxdepth 1 -type f -not -name ".*" -not -path "./logs/*" -delete 2>/dev/null || true
            find . -maxdepth 1 -type d -not -name "." -not -name ".git" -not -name "logs" -exec rm -rf {} + 2>/dev/null || true
            
            # Copy logs to this branch
            cp -r logs/* . 2>/dev/null || true
            
            # Add and commit logs
            git add *.json *.html 2>/dev/null || true
            if ! git diff --staged --quiet; then
              git commit -m "ðŸ“Š Update pipeline logs - $(date '+%Y-%m-%d %H:%M:%S')"
              git push origin release-logs
            fi
            
            # Switch back to main branch
            git checkout main
          fi

      - name: Cleanup
        if: always()
        run: |
          rm -rf downloads/
          rm -rf temp/
          rm -rf output/original/
